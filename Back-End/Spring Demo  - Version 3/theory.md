# Spring

* Центральное понятие Spring - IoC-контейнер (контейнер бинов, Spring Context)
* Контейнер бинов - содержит все бины с их связями
* Бин - компонент, какой-то объект, бин имеет свой идентификатор (id) и тип, на основе которого он создан.
* IoC/DI - Inversion of Control/Dependency Injection - принцип, когда создание и связывание компонентов мы выносим в отдельные модули
* Эти модули отвечают за конфигурацию приложения (в данном случае, это `ApplicationConfig`)
* `Inject` - инъекция, это когда бин из контейнера подставляется в другой бин или параметр, поле и т.д.

* `ApplicationContext` - интерфейс, который описывает поведение `контейнера бинов`
* `AnnotationConfigApplicationContext` - реализация контейнера бинов на основе аннотаций.
* `getBean` - метод для получения бина из контейнера. Если бин подходящего типа один - проблем нет, если более одного - нужно указать его id
* `@Autowired` - данную аннотацию можно вешать на поле, конструктор или сеттер. Благодаря этой аннотации Spring делает inject какого-либо бина, подходящего по типу.
* `@ComponentScan` - вешаем данную аннотацию на класс-конфигурации. В ней указываем пакеты, где нужно искать классы с `@Component`

## Способы объявления бинов

### 1. Аннотация @Bean

* С помощью этой аннотации мы указываем фабричный метод, создающий какой-либо бин
* Название метода - id бина
* Если нашему бину нужны какие-то другие бины, их можно перечислить в параметрах метода с аннотацией `@Bean`
* Если кандидатов несколько - то используем аннотацию `@Qualifier`, где указываем идентификатор нужного бина

### 2. Аннотация @Component

* Данной аннотацией помечаем класс, на основе которого будет создан бин
* По умолчанию, id этого бина - название класса, только с маленькой буквы. Но можно назначить свой id.
* А можно ли все-таки некоторые "сложные" бины тоже объявить как компонент?

### 3. Работа с Properties-файлами 

* Некоторые свойства приложения можно выносить в отдельный файл `properties`
* Тогда необходимо в конфигурационном файле указать путь к этому файлу через `@PropertySource` - `@PropertySource(value = "classpath:application.properties")`
* В самих компонентах просто используем аннотацию `@Value` с указанием названия свойства

### Резюмируя 

* Получили такой код, где мы не думаем о связывании и создании объектов, мы просто пользуемся тем, что дает нам Spring
* Он сам настраивает наше приложение

### Как бывает в реальном проекте?

* Как правило, у каждого бина только одна реализация, поэтому можно не использовать `@Qualifier`
* Можно не использовать `@Autowired`
* Вместо аннотации `@Component` можно использовать синонимы, чтобы улучшить понимание бина.
  * `@Service`
  * `@Repository`
* Можно использовать lombok для сокращения количества кода